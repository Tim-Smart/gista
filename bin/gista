#!/usr/bin/env node
// Generated by CoffeeScript 1.7.1
var Client, async, client, createGist, deleteGist, ensureGistId, exec, files, fromFiles, fromStdin, fs, generateToken, help, is_gentoken, is_stdin, known_opts, loadConfig, nopt, options, path, read, read_opts, short_opts, starGist, tty, url;

Client = require('node-gist').Client;

nopt = require('nopt');

path = require('path');

url = require('url');

tty = require('tty').isatty(process.stdout.fd);

fs = require('fs');

async = require('async-array').async;

read = require('read');

exec = require('child_process').exec;

client = null;

help = "Create a Gist from a file or stdin using node-gist.\n\ngista -pd \"My cool gist\" [file.ext]\n\nOptions:\n  -f, --fetch     Fetch a gist by id or url\n  -e, --edit      Edit a gist by id or url\n  -*, --star      Star a gist by id or url\n  -x, --delete    Delete a gist by id or url\n  -p, --public    Create a public gist\n  -n, --name      Set the file name\n  -d, --desc      Add a description\n  -t, --type      Set the file extension\n  -a, --token     Manually set the oauth token\n  -u, --user      Manually set Github username. If --password is\n                  not provided, a password prompt will appear\n      --password  Manually set Github password\n      --gentoken  Generate a token from provided token/credentials\n      --tty       Force tty mode for output formatting\n  -v, --verbose   When reading from stdin, echo input back to stdout\n  -h, --help      You looking at it\n\nGetting Started:\n  1. Get a token (gista doesn't store your password anywhere)\n    gista --user github-user --gentoken\n  2. Export token somewhere to $GISTA_TOKEN\n    echo \"export GISTA_TOKEN=xxx\" >> ~/.bashrc\n  3. Restart your shell and start gist'n.\n    echo \"Hello world.\" | gista -n hello-world.txt\n";

known_opts = {
  "public": Boolean,
  fetch: String,
  edit: String,
  star: String,
  "delete": String,
  name: String,
  desc: String,
  type: String,
  token: String,
  gentoken: Boolean,
  password: String,
  user: String,
  tty: Boolean,
  verbose: Boolean,
  help: Boolean
};

short_opts = {
  f: '--fetch',
  e: '--edit',
  '*': '--star',
  x: '--delete',
  p: ['--public', 'true'],
  n: '--name',
  d: '--desc',
  t: '--type',
  a: '--token',
  u: '--user',
  v: '--verbose',
  h: '--help'
};

options = nopt(known_opts, short_opts);

if (options.tty == null) {
  options.tty = tty;
}

read_opts = {
  prompt: 'Password: ',
  silent: true
};

if (options.help) {
  console.log(help);
  return process.exit();
}

ensureGistId = function(id) {
  id = (url.parse(id)).pathname;
  id = id.split('/').pop();
  return id;
};

if (options.fetch) {
  client = new Client;
  return client.get("/" + (ensureGistId(options.fetch)), function(error, gist) {
    var file, files, multiple, ret, _i, _len;
    if (error) {
      throw error;
    }
    try {
      files = Object.keys(gist.files);
    } catch (_error) {
      error = _error;
      throw new Error('Gist not found');
    }
    multiple = files.length > 1;
    if (!multiple) {
      return process.stdout.write(gist.files[files[0]].content);
    }
    ret = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      ret.push([file, '\n', new Array(file.length + 1).join('='), '\n\n', gist.files[file].content].join(''));
    }
    return console.log(ret.join('\r\n'));
  });
}

files = options.argv.remain;

is_gentoken = options.gentoken === true;

is_stdin = options.argv.remain.length === 0;

loadConfig = function(callback) {
  var ask_password, gotPassword;
  ask_password = !!options.user && !options.token;
  if (!options.user) {
    options.user = process.env.GITHUB_USER;
  }
  if (!options.password) {
    options.password = process.env.GITHUB_PASSWORD;
  }
  if (!options.token) {
    options.token = process.env.GISTA_TOKEN;
  }
  gotPassword = function(error, password) {
    var task;
    if (error) {
      throw error;
    }
    options.password = password;
    if (options.token) {
      options.user = null;
      options.password = null;
      return callback();
    }
    task = async([]);
    if (!options.user) {
      task.push('user');
    }
    if (!options.password) {
      task.push('password');
    }
    return task.forEach(function(item, i, next) {
      return exec("git config --global github." + item, function(error, stdout) {
        if (error) {
          return next();
        }
        options[item] = stdout.trim();
        return next();
      });
    }).exec(function(error, results) {
      var has_userpass;
      has_userpass = (options.user && options.password) !== null;
      if (!has_userpass) {
        options.user = options.password = null;
      }
      if (error) {
        return callback(error);
      }
      return callback();
    });
  };
  if (ask_password) {
    options.token = null;
    options.password = null;
    return read(read_opts, gotPassword);
  }
  return gotPassword(null, options.password);
};

generateToken = function() {
  var authorization;
  client.path = '';
  authorization = {
    scopes: ['gist'],
    note: 'gista CLI',
    note_url: 'https://github.com/tim-smart/gista'
  };
  return client.post('/authorizations', authorization, function(error, data) {
    if (error) {
      throw error;
    }
    if (!data.token) {
      throw new Error('Token generation refused by Github.');
    }
    console.log(data.token);
    return console.error("\nFor continued use of this token by the gista cli tool, make\nyou assign it to the GISTA_TOKEN environment variable in your\nbash profile.");
  });
};

starGist = function() {
  return client.put("/" + (ensureGistId(options.star)) + "/star", function(error) {
    if (error) {
      throw error;
    }
  });
};

deleteGist = function() {
  return client["delete"]("/" + (ensureGistId(options["delete"])), function(error) {
    if (error) {
      throw error;
    }
  });
};

fromStdin = function() {
  var data, first;
  data = '';
  first = true;
  process.stdin.resume();
  process.stdin.setEncoding('utf8');
  process.stdin.on('data', function(chunk) {
    if (options.verbose) {
      if (first) {
        process.stdout.write("> ");
        first = false;
      }
      process.stdout.write(chunk.split("\n").join("\n> "));
    }
    return data += chunk;
  });
  return process.stdin.on('end', function() {
    if (options.verbose) {
      process.stdout.write("EOF\n");
    }
    return createGist([
      {
        name: options.name || 'stdout.txt',
        content: data
      }
    ]);
  });
};

fromFiles = function() {
  if (files.length > 10) {
    throw new Error('Over 10 files.');
  }
  return async(files).map(function(file, i, next) {
    return fs.readFile(file, 'utf8', function(error, content) {
      var name;
      if (error) {
        return next(error);
      }
      name = options.name || path.basename(file);
      return next(null, {
        name: name,
        content: content
      });
    });
  }).exec(function(error, results) {
    if (error) {
      throw error;
    }
    return createGist(results.array());
  });
};

createGist = function(files) {
  var doneGist, file, gist, is_public, name, type, _i, _len;
  is_public = options["public"];
  if (is_public == null) {
    is_public = false;
  }
  gist = {
    "public": is_public,
    files: {}
  };
  if (options.desc) {
    gist.description = options.desc;
  }
  type = options.type ? '.' + options.type || null : void 0;
  for (_i = 0, _len = files.length; _i < _len; _i++) {
    file = files[_i];
    name = file.name;
    if (type) {
      name = name + type;
    }
    gist.files[name] = {
      content: file.content
    };
  }
  doneGist = function(error, gist) {
    if (error) {
      throw error;
    }
    if (gist.message) {
      throw new Error(gist.message);
    }
    if (!options.tty) {
      return process.stdout.write(gist.url);
    }
    return console.log(gist.url);
  };
  if (options.edit) {
    return client.patch("/" + (ensureGistId(options.edit)), gist, doneGist);
  }
  return client.post('', gist, doneGist);
};

loadConfig(function(error) {
  if (error) {
    throw error;
  }
  client = new Client({
    user: options.user,
    password: options.password,
    token: options.token
  });
  if (options.star) {
    return starGist();
  }
  if (options["delete"]) {
    return deleteGist();
  }
  if (is_gentoken) {
    return generateToken();
  }
  if (is_stdin) {
    return fromStdin();
  }
  return fromFiles();
});
